设立”严格模式“的目的，主要有以下几个。

明确禁止一些不合理、不严谨的语法，减少JavaScript的一些怪异行为。
增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。
提高编译器效率，增加运行速度。
为未来新版本的JavaScript做好铺垫。

`启用方法`

```
'use strict';
```

（1） 针对整个脚本文件

将use strict放在脚本文件的第一行，则整个脚本都将以“严格模式”运行。如果这行语句不在第一行就无效，整个脚本会以“正常模式”运行。(严格地说，只要前面不是产生实际运行结果的语句，use strict可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)

`如果字符串use strict出现在代码中间，则不起作用，即严格模式必须从代码一开始就生效。`

（2）针对单个函数

use strict放在函数体的第一行，则整个函数以“严格模式”运行。

（3）脚本文件的变通写法

将整个脚本文件放在一个立即执行的匿名函数之中。

```
(function () {
  'use strict';
  // some code here
})();
```

显式报错

1. 只读属性不可写

严格模式下，设置字符串的length属性，会报错。

严格模式下，对只读属性赋值，或者删除不可配置（nonconfigurable）属性都会报错。

2. 只设置了赋值器的属性不可写

严格模式下，对一个只设置了赋值器（getter）的属性赋值，会报错。

```
'use strict';

var o = {
  get v() { return 1; }
};

o.v = 2; // 报错
```

3. 禁止扩展的对象不可扩展

严格模式下，对禁止扩展的对象添加新属性，会报错。

```
'use strict';

var o = {};
Object.preventExtensions(o);
o.v = 1; // 报错
```

4. eval、arguments不可用作标识名

严格模式下，使用eval或者arguments作为标识名，将会报错。

5. 函数不能有重名的参数

正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。

6. 禁止八进制的前缀0表示法

正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。

```
"use strict";
var n = 0100; // SyntaxError
```

增强的安全措施

1. 全局变量显式声明

在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。

2. 禁止this关键字指向全局对象

正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。

严格模式下，函数直接调用时（不使用new调用），函数内部的this表示undefined，因此可以用call、apply和bind方法，将任意值绑定在this上面。

3. 禁止使用fn.callee、fn.caller

函数内部不得使用fn.caller、fn.arguments，否则会报错。这意味着不能在函数内部得到调用栈了。

4. 禁止使用arguments.callee、arguments.caller

arguments.callee和arguments.caller是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用arguments.callee、arguments.caller将会报错。

5. 禁止删除变量

严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。

静态绑定

JavaScript语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。

严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。

具体来说，涉及以下几个方面。

1. 禁止使用with语句

严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。

```
'use strict';
var v  = 1;

with (o) { // SyntaxError
  v = 2;
}
```

2. 创设eval作用域

正常模式下，JavaScript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。

`正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。`

3. arguments不再追踪参数的变化

变量arguments代表函数的参数。严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系。


**向下一个版本的JavaScript过渡**

avaScript语言的下一个版本是ECMAScript 6，为了平稳过渡，严格模式引入了一些ES6语法。

1. 非函数代码块不得声明函数

JavaScript的新版本ES6会引入“块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。

```
'use strict';
if (true) {
  function f1() { } // 语法错误
}

for (var i = 0; i < 5; i++) {
  function f2() { } // 语法错误
}
```

2. 保留字

为了向将来JavaScript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。

使用这些词作为变量名将会报错。

此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。

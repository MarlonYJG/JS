# 目录 #

> 1. 概述

>           1.1 生成方法
>           1.2 键名
>           1.3 属性
>           1.4 对象的引用
>           1.5 表达式还是语句?

> 2. 属性的操作

>           2.1 读取属性
>           2.2 检查变量是否声明
>           2.3 属性的赋值
>           2.4 检查所有属性
>           2.5 delete命令
>           2.6 in运算符
>           2.7 for...in循环

> 3. with语句

## 概述 ##

1. 生成方法

    对象(object)是JavaScript语言的核心概念，也是最重要的数据类型

    对象就是一组“键值对”(key-value)的集合，是一种无序的复合数据集合

    对象的生成方法，通常有三种方法。除了像上面那样直接使用大括号生成（{}），还可以用new命令生成一个Object对象的实例，或者使用Object.create方法生成。

    ```
    var o1 = {};
    var o2 = new Object();
    var o3 = Object.create(Object.prototype);
    ```

    `上面三行语句是等价的。一般来说，第一种采用大括号的写法比较简洁，第二种采用构造函数的写法清晰地表示了意图，第三种写法一般用在需要对象继承的场合。`

    2. 键名


    对象的所有键名都是字符串，所以加不加引号都可以。
    如果键名是数值，会被自动转为字符串。

    但是，如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。
    ```
    var o = {
        '1p': "Hello World",
        'h w': "Hello World",
        'p+q': "Hello World"
    };
    ```
    上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。

    注意，JavaScript的保留字可以不加引号当作键名。
    ```
    var obj = {
        for: 1,
        class: 2
    };
    ```
3. 属性

    对象的每一个“键名”又称为“属性”（property），它的“键值”可以是`任何数据类型`。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。
    ```
    var o = {
        p: function (x) {
            return 2 * x;
        }
    };

        o.p(1)
        // 2
    ```

4. 对象的引用

    `如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。`
    ```
    var o1 = {};
    var o2 = o1;

    o1.a = 1;
    o2.a // 1

    o2.b = 2;
    o1.b // 2
    ```
    上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。

    此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。

    ```
    var o1 = {};
    var o2 = o1;

    o1 = 1;
    o2 // {}
    ```
    上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。

    `但是，这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。`

    ```
    var x = 1;
    var y = x;

    x = 2;
    y // 1
    ```
    上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。

5. 表达式还是语句？

对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？
```
{ foo: 123 }
```
JavaScript引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。

为了避免这种歧义，`JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。`
```
({ foo: 123})
```
这种差异在eval语句中反映得最明显。
```
eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
```
上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。

## 属性的操作 ##

1. 读取属性

    读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

    `方括号运算符内部可以使用表达式。`

    ```
    o['hello' + ' world']
    o[3 + 3]
    ```
    `数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。`
    ```
    obj.0xFF
    // SyntaxError: Unexpected token
    obj[0xFF]
    // true
    ```

2. 检查变量是否声明

    如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个全局变量是否被声明。

    ```
    // 检查a变量是否被声明
    if (a) {...} // 报错

    if (window.a) {...} // 不报错
    if (window['a']) {...} // 不报错
    ```

    上面的后二种写法之所以不报错，是因为在浏览器环境，所有全局变量都是window对象的属性。window.a的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错。

    需要注意的是，后二种写法有漏洞，`如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。正确的做法是可以采用下面的写法。`
    ```
    if ('a' in window) {
    // 变量 a 声明过
    } else {
    // 变量 a 未声明
    }
    ```
3. 属性的赋值

    JavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。

4. 查看所有属性

    查看一个对象本身的所有属性，可以使用Object.keys方法。
    ```
    var o = {
        key1: 1,
        key2: 2
    };

        Object.keys(o);
        // ['key1', 'key2']
    ```

5. 删除命令

    delete命令用于删除对象的属性，删除成功后返回true。

    注意，删除一个不存在的属性，delete不报错，而且返回true。

    ```
    var o = {};
    delete o.p // true
    ```

    上面代码中，o对象并没有p属性，但是delete命令照样返回true。`因此，不能根据delete命令的结果，认定某个属性是存在的，只能保证读取这个属性肯定得到undefined。`

    只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。

    ```
    var o = bject.defineProperty({}, 'p', {
  value: 123,
  configurable: false
});

o.p // 123
delete o.p // false
    ```
    另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》一节）。

    最后，delete命令不能删除var命令声明的变量，只能用来删除属性。
    ```
    var p = 1;
    delete p // false
    delete window.p // false
    ```
    上面命令中，p是var命令声明的变量，delete命令无法删除它，返回false。因为var声明的全局变量都是顶层对象的属性，而且默认不得删除。

6. in运算符

    in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。

    在JavaScript语言中，所有全局变量都是顶层对象（浏览器的顶层对象就是window对象）的属性，因此可以用in运算符判断，一个全局变量是否存在。

    ```
    // 假设变量x未定义

    // 写法一：报错
    if (x) { return 1; }

    // 写法二：不正确
    if (window.x) { return 1; }

    // 写法三：正确
    if ('x' in window) { return 1; }
    ```
    上面三种写法之中，如果x不存在，第一种写法会报错；如果x的值对应布尔值false（比如x等于空字符串），第二种写法无法得到正确结果；只有第三种写法，才能正确判断变量x是否存在。

    `in运算符的一个问题是，它不能识别对象继承的属性。`

    ```
    var o = new Object();
    o.hasOwnProperty('toString') // false

    'toString' in o // true
    ```
    上面代码中，toString方法不是对象o自身的属性，而是继承的属性，hasOwnProperty方法可以说明这一点。但是，in运算符不能识别，对继承的属性也返回true。

7. for...in循环

    `for...in循环用来遍历一个对象的全部属性。`

    下面是一个使用for...in循环，提取对象属性的例子。
    ```
    var obj = {
    x: 1,
    y: 2
    };
    var props = [];
    var i = 0;

    for (props[i++] in obj);

    props // ['x', 'y']
    ```    

    `for...in循环有两个使用注意点。`
    > 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性
    > 它不仅遍历对象自身的属性，还遍历继承的属性。
    ```
    // name 是 Person 本身的属性
    function Person(name) {
    this.name = name;
    }

    // describe是Person.prototype的属性
    Person.prototype.describe = function () {
    return 'Name: '+this.name;
    };

    var person = new Person('Jane');

    // for...in循环会遍历实例自身的属性（name），
    // 以及继承的属性（describe）
    for (var key in person) {
    console.log(key);
    }
    // name
    // describe
    ```

    上面代码中，name是对象本身的属性，describe是对象继承的属性，for...in循环的遍历会包括这两者。

    如果只想遍历对象本身的属性，可以使用hasOwnProperty方法，在循环内部判断一下是不是自身的属性。

    ```
    for (var key in person) {
    if (person.hasOwnProperty(key)) {
        console.log(key);
    }
    }
    // name
    ```
    对象person其实还有其他继承的属
    性，比如toString。

    这个toString属性不会被for...in循环遍历到，因为它默认设置为“不可遍历”，详见《标准库》一章的Object对象部分。

    `一般情况下，都是只想遍历对象自身的属性，所以不推荐使用for...in循环。`

## with语句 ##

它的作用是操作同一个对象的多个属性时，提供一些书写的方便。

注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。

```
var o = {};

with (o) {
  x = "abc";
}

o.x // undefined
x // "abc"
```

上面代码中，对象o没有属性x，所以with区块内部对x的操作，等于创造了一个全局变量x。正确的写法应该是，先定义对象o的属性x，然后在with区块内操作它。
```
var o = {};
o.x = 1;

with (o) {
  x = 2;
}

o.x // 2
```
这是with语句的一个很大的弊病，就是绑定对象不明确。

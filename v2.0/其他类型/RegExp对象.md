概述
正则对象的属性和方法

    属性
    test()
    exec()

字符串对象的方法

    String.prototype.match()
    String.prototype.search()
    String.prototype.replace()
    String.prototype.split()

匹配规则

    字面量字符和元字符
    转义符
    特殊字符
    字符类
    预定义模式
    重复类
    量词符
    贪婪模式
    修饰符
    组匹配

**概述**

新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。

另一种是使用 RegExp 构造函数。

```
var regex = /xyz/;

var regex = new RegExp('xyz');
```

上面两种写法是等价的，都新建了一个内容为xyz的正则表达式对象。它们的主要区别是，第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。

RegExp 构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。

```
var regex = new RegExp('xyz', "i");
// 等价于
var regex = /xyz/i;
```

`这两种写法——字面量和构造函数——在运行时有一个细微的区别。采用字面量的写法，正则对象在代码载入时（即编译时）生成；采用构造函数的方法，正则对象在代码运行时生成。考虑到书写的便利和直观，实际应用中，基本上都采用字面量的写法。`

则对象生成以后，有两种使用方式：

正则对象的方法：将字符串作为参数，比如regex.test(string)。
字符串对象的方法：将正则对象作为参数，比如string.match(regex)。

**正则对象的属性和方法**

`属性`

正则对象的属性分成两类。

一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。

```
ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。
global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。
multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。
```

另一类是与修饰符无关的属性，主要是下面两个。

```
lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。
source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。
```

`test()`

正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。

```
var r = /x/g;
var s = '_x_x';

r.lastIndex // 0
r.test(s) // true

r.lastIndex // 2
r.test(s) // true

r.lastIndex // 4
r.test(s) // false
```

带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。

```
var r = /x/g;
var s = '_x_x';

r.lastIndex = 4;
r.test(s) // false
```

上面代码指定从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回false。

lastIndex属性只对同一个正则表达式有效，所以下面这样写是错误的。

```
var count = 0;
while (/a/g.test('babaa')) count++;
```

如果正则模式是一个空字符串，则匹配所有字符串。

`exec()`

正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。

如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。

```
var s = '_x_x';
var r = /_(x)/;

r.exec(s) // ["_x", "x"]
```

上面代码的exec方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。

exec方法的返回数组还包含以下两个属性：

input：整个原字符串。
index：整个模式匹配成功的开始位置（从0开始计数）。

正则对象的lastIndex属性不仅可读，还可写。一旦手动设置了lastIndex的值，就会从指定位置开始匹配。但是，这只在设置了g修饰符的情况下，才会有效。

如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。

**字符串对象的方法**

字符串对象的方法之中，有4种与正则对象有关。

match()：返回一个数组，成员是所有匹配的子字符串。
search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
replace()：按照给定的正则表达式进行替换，返回替换后的字符串。
split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

`String.prototype.match()`

字符串对象的match方法对字符串进行正则匹配，返回匹配结果。

字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。

`如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。`

设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。

`String.prototype.search()`

字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。

`String.prototype.replace()`

字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。

```
str.replace(search, replacement)
```

搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。

$& 指代匹配的子字符串。
$` 指代匹配结果前面的文本。
$' 指代匹配结果后面的文本。
$n 指代匹配成功的第n组内容，n是从1开始的自然数。
$$ 指代美元符号$。

```
'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
// "world hello"

'abc'.replace('b', '[$`-$&-$\']')
// "a[a-b-c]c"
```

replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。

```
'3 and 5'.replace(/[0-9]+/g, function(match){
  return 2 * match;
})
// "6 and 10"

var a = 'The quick brown fox jumped over the lazy dog.';
var pattern = /quick|brown|lazy/ig;

a.replace(pattern, function replacer(match) {
  return match.toUpperCase();
});
// The QUICK BROWN fox jumped over the LAZY dog.
```

作为replace方法第二个参数的替换函数，可以接受多个参数。第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。

`String.prototype.split()`

字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。

```
str.split(separator, [limit])
```

该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。

如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。

```
'aaa*a*'.split(/(a*)/)
// [ '', 'aaa', '*', 'a', '*' ]
```

上面代码的正则表达式使用了括号，第一个组匹配是“aaa”，第二个组匹配是“a”，它们都作为数组成员返回。

**匹配规则**

`字面量字符和元字符`

大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。

除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。

（1）点字符（.)

点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。

（2）位置字符

位置字符用来提示字符所处的位置，主要有两个字符。

^ 表示字符串的开始位置
$ 表示字符串的结束位置

（3）选择符（|）

竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。

多个选择符可以联合使用。

其他的元字符还包括\\、\*、+、?、()、[]、{}等，将在下文解释。

`转义符`

正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成\+。

正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

`特殊字符`

正则表达式对一些不能打印的特殊字符，提供了表达方法。

\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。
[\b] 匹配退格键(U+0008)，不要与\b混淆。
\n 匹配换行键。
\r 匹配回车键。
\t 匹配制表符tab（U+0009）。
\v 匹配垂直制表符（U+000B）。
\f 匹配换页符（U+000C）。
\0 匹配null字符（U+0000）。
\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。
\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的unicode字符。

`字符类`

字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。

有两个字符在字符类中有特殊含义。

（1）脱字符（^）

如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。

如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。

`注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。`

（2）连字符（-）

某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。

注意，字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。

连字符还可以用来指定Unicode字符的范围。

`预定义模式`

预定义模式指的是某些常见模式的简写方式。

\d 匹配0-9之间的任一数字，相当于[0-9]。
\D 匹配所有0-9以外的字符，相当于[^0-9]。
\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
\s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。
\S 匹配非空格的字符，相当于[^\t\r\n\v\f]。
\b 匹配词的边界。
\B 匹配非词边界，即在词的内部。

`重复类`

模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。

`量词符`

```
量词符用来设定某个模式出现的次数。

? 问号表示某个模式出现0次或1次，等同于{0, 1}。
* 星号表示某个模式出现0次或多次，等同于{0,}。
+ 加号表示某个模式出现1次或多次，等同于{1,}。
```

`贪婪模式`

上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。

如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。

除了非贪婪模式的加号，还有非贪婪模式的星号（*）。

```
*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。
```

`修饰符`

修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。

修饰符可以单个使用，也可以多个一起使用。

（1）g修饰符

默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

（2）i修饰符

默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。

（3）m修饰符

m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。

`组匹配`

（1）概述

正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。

在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。

（2）非捕获组

(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。

（3）先行断言

x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。

“先行断言”中，括号里的部分是不会返回的。

```
var m = 'abc'.match(/b(?=c)/);
m // ["b"]

```

（4）先行否定断言

x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。

“先行否定断言”中，括号里的部分是不会返回的。
  